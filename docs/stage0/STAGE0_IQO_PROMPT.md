# Stage 0: IQO Generation Prompt Specification

**Version**: 1.0
**Status**: Design Complete
**Last Updated**: 2025-12-01

---

## 1. Purpose

The Intent Query Object (IQO) tells the DCC how to search local-memory and the vector database. It is generated by a fast local LLM (Ollama) from the spec content and environment context.

### Goals

- **Predictable JSON**: No commentary, no hallucination
- **Actionable filters**: Domains, tags, keywords that map to real data
- **Forward-compatible**: Includes `notebook_focus` for future multi-notebook routing

---

## 2. IQO Schema

```jsonc
{
  "domains": ["spec-kit", "infrastructure"],
  "required_tags": ["spec:SPEC-KIT-102"],
  "optional_tags": ["stage:plan", "type:pattern"],
  "keywords": ["NotebookLM", "Tiered Memory", "Stage 0"],
  "max_candidates": 150,
  "notebook_focus": ["architecture", "bugs"],
  "confidence": 0.85  // optional, for explainability
}
```

### Field Definitions

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `domains` | string[] | Yes | 0-3 high-level project areas |
| `required_tags` | string[] | Yes | Tags that MUST be present in candidates |
| `optional_tags` | string[] | Yes | Tags that bias retrieval (not hard filters) |
| `keywords` | string[] | Yes | 3-10 phrases for semantic search |
| `max_candidates` | number | Yes | Upper bound for pre-filter (max 150) |
| `notebook_focus` | string[] | No | Hints for Tier 2 notebook routing |
| `confidence` | number | No | 0.0-1.0, overall IQO confidence |

### Domain Taxonomy (Known Values)

```
spec-kit       # Spec-kit pipeline, automation
infrastructure # Build, CI/CD, deployment
tui            # TUI implementation, widgets
cli            # CLI commands, parsing
core           # Core library, protocols
mcp            # MCP client/server
ollama         # Ollama integration
testing        # Test infrastructure
docs           # Documentation, specs
```

Unknown domains should be omitted (prefer empty array).

### Tag Namespaces

| Prefix | Example | Meaning |
|--------|---------|---------|
| `spec:` | `spec:SPEC-KIT-102` | Links to a specific SPEC |
| `stage:` | `stage:plan` | Pipeline stage context |
| `type:` | `type:pattern`, `type:anti-pattern` | Memory classification |
| `component:` | `component:dcc` | Codebase component |
| `agent:` | `agent:claude` | Agent that created memory |

### Notebook Focus Values

| Value | When to include |
|-------|-----------------|
| `architecture` | Spec affects system design, dependencies, core components |
| `bugs` | Spec is about bugfixing, reliability, regressions |
| `diary` | Spec needs project history, velocity, recurring blockers |

---

## 3. Prompt Templates

### 3.1 System Prompt

```text
You are a search-intent extraction assistant for the codex-rs project.
Your job is to transform a specification and environment context into a compact JSON object called an Intent Query Object (IQO).
The IQO is used to search a local-memory knowledge base and a vector database.

You MUST:
- Output ONLY valid JSON (no extra text, no markdown, no explanation).
- Use short, plausible values that reflect the input spec.
- Prefer existing domain/tag patterns if they are clearly implied.
- When unsure, leave arrays empty rather than guess wildly.
- Set confidence to reflect how well you understood the spec (0.0-1.0).

Known domains: spec-kit, infrastructure, tui, cli, core, mcp, ollama, testing, docs
Tag prefixes: spec:, stage:, type:, component:, agent:
Notebook focus values: architecture, bugs, diary
```

### 3.2 User Prompt Template

```text
Given the following specification and environment context, generate an Intent Query Object (IQO).

The IQO JSON MUST have this exact shape:

{
  "domains": string[],          // 0-3 high-level project areas
  "required_tags": string[],    // tags that MUST match
  "optional_tags": string[],    // tags that bias retrieval
  "keywords": string[],         // 3-10 phrases for semantic search
  "max_candidates": number,     // integer, max 150
  "notebook_focus": string[],   // hints: "architecture", "bugs", "diary"
  "confidence": number          // 0.0-1.0, your confidence in this IQO
}

Rules:

1. domains: Choose from known values (spec-kit, infrastructure, tui, cli, core, mcp, ollama, testing, docs). Use [] if unsure.

2. required_tags: Include exact spec IDs (e.g., "spec:SPEC-KIT-102") and other MUST-match tags. Use [] if none are certain.

3. optional_tags: Include helpful but non-mandatory tags (stages, types, components). Prefer known prefixes.

4. keywords: Pick 3-10 phrases capturing the core topic. Include:
   - Feature names
   - Component names
   - Risk areas
   - Key concepts from the spec

5. max_candidates: Start at 150. Reduce only if spec is very narrow and focused.

6. notebook_focus:
   - Include "architecture" when spec affects system design or core components.
   - Include "bugs" when spec involves bugfixing, reliability, or regressions.
   - Include "diary" when spec needs project history or recurring patterns.
   - Include multiple if appropriate (e.g., ["architecture", "bugs"]).

7. confidence: Set to 0.8+ if spec is clear and you understood it well. Set lower if ambiguous.

---

SPEC CONTENT:
---
{{SPEC_CONTENT}}
---

ENVIRONMENT CONTEXT:
- cwd: {{CWD}}
- branch: {{BRANCH}}
- recent_files: {{RECENT_FILES}}

---

Output ONLY the JSON object. No commentary.
```

---

## 4. Post-Processing & Validation

After receiving LLM output, the Stage 0 engine must validate:

### 4.1 JSON Parsing

```rust
fn parse_iqo(raw: &str) -> Result<IQO, IQOError> {
    // Try direct JSON parse
    if let Ok(iqo) = serde_json::from_str::<IQO>(raw) {
        return Ok(validate_iqo(iqo));
    }

    // Try extracting JSON from markdown code fence
    if let Some(json_str) = extract_json_from_code_fence(raw) {
        if let Ok(iqo) = serde_json::from_str::<IQO>(&json_str) {
            return Ok(validate_iqo(iqo));
        }
    }

    // Fallback: return default IQO
    Err(IQOError::ParseFailed(raw.to_string()))
}
```

### 4.2 Validation Rules

```rust
fn validate_iqo(mut iqo: IQO) -> IQO {
    // Clamp max_candidates to configured max
    const MAX_CANDIDATES_LIMIT: usize = 150;
    if iqo.max_candidates > MAX_CANDIDATES_LIMIT {
        iqo.max_candidates = MAX_CANDIDATES_LIMIT;
    }

    // Filter unknown domains
    let known_domains = ["spec-kit", "infrastructure", "tui", "cli",
                         "core", "mcp", "ollama", "testing", "docs"];
    iqo.domains.retain(|d| known_domains.contains(&d.as_str()));

    // Filter unknown notebook_focus
    let known_focus = ["architecture", "bugs", "diary"];
    iqo.notebook_focus.retain(|f| known_focus.contains(&f.as_str()));

    // Clamp confidence
    iqo.confidence = iqo.confidence.clamp(0.0, 1.0);

    // Limit keywords to 10
    iqo.keywords.truncate(10);

    iqo
}
```

### 4.3 Fallback IQO

If parsing fails completely, use a minimal fallback:

```rust
fn fallback_iqo(spec_id: &str, spec_content: &str) -> IQO {
    IQO {
        domains: vec![],
        required_tags: vec![format!("spec:{}", spec_id)],
        optional_tags: vec![],
        keywords: extract_nouns_heuristically(spec_content, 5),
        max_candidates: 150,
        notebook_focus: vec!["architecture".to_string()],
        confidence: 0.3,
    }
}
```

---

## 5. Example IQOs

### Example 1: Feature Spec (Clear)

**Input spec**: "Add NotebookLM integration for Stage 0 deep research"

```json
{
  "domains": ["spec-kit", "mcp"],
  "required_tags": ["spec:SPEC-KIT-102"],
  "optional_tags": ["type:pattern", "stage:plan"],
  "keywords": ["NotebookLM", "Stage 0", "deep research", "Tier 2", "local-memory", "DCC"],
  "max_candidates": 150,
  "notebook_focus": ["architecture"],
  "confidence": 0.9
}
```

### Example 2: Bug Fix (Narrow)

**Input spec**: "Fix race condition in consensus coordinator"

```json
{
  "domains": ["core", "spec-kit"],
  "required_tags": [],
  "optional_tags": ["type:anti-pattern", "component:consensus"],
  "keywords": ["race condition", "consensus coordinator", "concurrency", "lock"],
  "max_candidates": 50,
  "notebook_focus": ["bugs"],
  "confidence": 0.85
}
```

### Example 3: Ambiguous Spec (Low Confidence)

**Input spec**: "Improve performance"

```json
{
  "domains": [],
  "required_tags": [],
  "optional_tags": ["type:pattern"],
  "keywords": ["performance", "optimization", "latency", "throughput"],
  "max_candidates": 150,
  "notebook_focus": ["architecture", "bugs"],
  "confidence": 0.4
}
```

---

## 6. Integration

### 6.1 Code Location

```
codex-rs/stage0/src/dcc/
├── mod.rs
├── iqo.rs           # IQO types and generation
├── iqo_prompt.rs    # Prompt templates (this spec)
└── retrieval.rs     # Uses IQO for search
```

### 6.2 Usage in DCC

```rust
// In dcc/mod.rs
pub async fn compile_context(
    &self,
    spec_id: &str,
    spec_content: &str,
    env: &EnvContext,
    config: &Stage0Config,
) -> Result<CompileResult> {
    // Step 1: Generate IQO
    let iqo = self.generate_iqo(spec_content, env).await?;

    // Step 2: Query local-memory using IQO
    let candidates = self.search_with_iqo(&iqo).await?;

    // Step 3: Join with overlay scores, rerank
    let ranked = self.rank_and_diversify(candidates, &iqo)?;

    // Step 4: Summarize into TASK_BRIEF
    let task_brief = self.summarize_to_brief(&ranked, spec_content).await?;

    Ok(CompileResult { iqo, ranked, task_brief })
}
```

---

## 7. Testing

### 7.1 Unit Tests

```rust
#[test]
fn test_iqo_validation_clamps_max_candidates() {
    let iqo = IQO { max_candidates: 500, ..Default::default() };
    let validated = validate_iqo(iqo);
    assert_eq!(validated.max_candidates, 150);
}

#[test]
fn test_iqo_validation_filters_unknown_domains() {
    let iqo = IQO {
        domains: vec!["spec-kit".into(), "fake-domain".into()],
        ..Default::default()
    };
    let validated = validate_iqo(iqo);
    assert_eq!(validated.domains, vec!["spec-kit"]);
}

#[test]
fn test_fallback_iqo_includes_spec_tag() {
    let iqo = fallback_iqo("SPEC-KIT-102", "Some content");
    assert!(iqo.required_tags.contains(&"spec:SPEC-KIT-102".to_string()));
}
```

### 7.2 Integration Tests

```rust
#[tokio::test]
async fn test_iqo_generation_with_real_spec() {
    let spec_content = include_str!("../../../test_fixtures/sample_spec.md");
    let env = EnvContext::default();

    let iqo = generate_iqo(spec_content, &env).await?;

    assert!(!iqo.keywords.is_empty());
    assert!(iqo.confidence > 0.0);
}
```

---

*Spec generated from research session P73 (2025-12-01)*
