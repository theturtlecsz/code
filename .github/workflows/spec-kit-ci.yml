name: Spec-Kit CI

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

defaults:
  run:
    shell: bash

jobs:
  spec-kit-review-contract:
    name: Review Exit Code Contract
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache-workspaces: codex-rs

      - name: Build CLI
        working-directory: codex-rs
        run: cargo build --release -p codex-cli

      - name: Set up smoke test environment
        run: |
          echo "FIXTURE_ROOT=${{ github.workspace }}/codex-rs/spec-kit/tests/fixtures/SPEC-CI-001" >> $GITHUB_ENV
          echo "CLI=${{ github.workspace }}/codex-rs/target/release/code" >> $GITHUB_ENV

      # =========================================================================
      # Exit Code Contract Tests (per REVIEW-CONTRACT.md / SPEC-CI-001 README)
      # =========================================================================

      - name: "[CLEAN] Expect exit 0 - no conflicts"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          ${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-clean \
            --stage plan \
            --json
          echo "✓ SPEC-CI-001-clean: exit 0 (clean consensus)"

      - name: "[CONFLICT] Expect exit 2 - blocking conflicts"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set +e  # Don't fail immediately on non-zero exit
          ${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-conflict \
            --stage plan \
            --json
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 2 ]; then
            echo "::error::Expected exit 2 for conflict case, got $EXIT_CODE"
            exit 1
          fi
          echo "✓ SPEC-CI-001-conflict: exit 2 (conflicts detected)"

      - name: "[MALFORMED-DEFAULT] Expect exit 0 - parse error is advisory"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          ${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-malformed \
            --stage plan \
            --json
          echo "✓ SPEC-CI-001-malformed (default): exit 0 (parse error advisory)"

      - name: "[MALFORMED-STRICT] Expect exit 3 - parse error with --strict-schema"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set +e
          ${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-malformed \
            --stage plan \
            --strict-schema \
            --json
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 3 ]; then
            echo "::error::Expected exit 3 for malformed+strict-schema, got $EXIT_CODE"
            exit 1
          fi
          echo "✓ SPEC-CI-001-malformed (--strict-schema): exit 3 (infrastructure error)"

      # =========================================================================
      # Additional Contract Validations
      # =========================================================================

      - name: "[STRICT-ARTIFACTS] Expect exit 2 for missing artifacts"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set +e
          ${{ env.CLI }} speckit review \
            --spec SPEC-NONEXISTENT \
            --stage plan \
            --strict-artifacts \
            --json
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 2 ]; then
            echo "::error::Expected exit 2 for missing artifacts with --strict-artifacts, got $EXIT_CODE"
            exit 1
          fi
          echo "✓ Missing artifacts with --strict-artifacts: exit 2"

      - name: "[JSON-STRUCTURE] Validate JSON output fields"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          OUTPUT=$(${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-clean \
            --stage plan \
            --json)

          # Validate required fields exist (pipefail ensures jq failures propagate)
          echo "$OUTPUT" | jq -e '.spec_id' > /dev/null || { echo "::error::Missing spec_id field"; exit 1; }
          echo "$OUTPUT" | jq -e '.stage' > /dev/null || { echo "::error::Missing stage field"; exit 1; }
          echo "$OUTPUT" | jq -e '.verdict' > /dev/null || { echo "::error::Missing verdict field"; exit 1; }
          echo "$OUTPUT" | jq -e '.exit_code' > /dev/null || { echo "::error::Missing exit_code field"; exit 1; }
          echo "$OUTPUT" | jq -e '.blocking_signals' > /dev/null || { echo "::error::Missing blocking_signals field"; exit 1; }
          echo "$OUTPUT" | jq -e '.advisory_signals' > /dev/null || { echo "::error::Missing advisory_signals field"; exit 1; }

          echo "✓ JSON structure validated"

      # =========================================================================
      # P4: Plan and Tasks Command Smoke Tests (SPEC-KIT-921)
      # =========================================================================

      - name: "[PLAN] Validate plan dry-run exits 0"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          OUTPUT=$(${{ env.CLI }} speckit plan \
            --spec SPEC-CI-001-clean \
            --dry-run \
            --json)

          # Validate schema versioning fields
          echo "$OUTPUT" | jq -e '.schema_version == 1' > /dev/null || { echo "::error::schema_version should be 1"; exit 1; }
          echo "$OUTPUT" | jq -e '.tool_version' > /dev/null || { echo "::error::Missing tool_version field"; exit 1; }
          echo "$OUTPUT" | jq -e '.status == "ready"' > /dev/null || { echo "::error::status should be 'ready'"; exit 1; }
          echo "$OUTPUT" | jq -e '.dry_run == true' > /dev/null || { echo "::error::dry_run should be true"; exit 1; }

          echo "✓ Plan dry-run: exit 0, schema_version=1, status=ready"

      - name: "[TASKS] Validate tasks dry-run exits 0"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          OUTPUT=$(${{ env.CLI }} speckit tasks \
            --spec SPEC-CI-001-clean \
            --dry-run \
            --json)

          # Validate schema versioning fields
          echo "$OUTPUT" | jq -e '.schema_version == 1' > /dev/null || { echo "::error::schema_version should be 1"; exit 1; }
          echo "$OUTPUT" | jq -e '.tool_version' > /dev/null || { echo "::error::Missing tool_version field"; exit 1; }
          echo "$OUTPUT" | jq -e '.status == "ready"' > /dev/null || { echo "::error::status should be 'ready'"; exit 1; }
          echo "$OUTPUT" | jq -e '.stage | contains("Tasks")' > /dev/null || { echo "::error::stage should contain 'Tasks'"; exit 1; }

          echo "✓ Tasks dry-run: exit 0, schema_version=1, stage=Tasks"

      - name: "[PIPELINE] plan → tasks → review smoke test"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail

          # Run plan validation (dry-run, model-free)
          ${{ env.CLI }} speckit plan \
            --spec SPEC-CI-001-clean \
            --dry-run \
            --json > /tmp/plan-output.json

          # Verify plan succeeded
          jq -e '.status == "ready"' /tmp/plan-output.json > /dev/null

          # Run tasks validation
          ${{ env.CLI }} speckit tasks \
            --spec SPEC-CI-001-clean \
            --dry-run \
            --json > /tmp/tasks-output.json

          # Verify tasks succeeded
          jq -e '.status == "ready"' /tmp/tasks-output.json > /dev/null

          # Verify review still works after plan→tasks
          ${{ env.CLI }} speckit review \
            --spec SPEC-CI-001-clean \
            --stage tasks \
            --json > /tmp/review-output.json

          # Validate review has schema versioning
          jq -e '.schema_version == 1' /tmp/review-output.json > /dev/null

          echo "✓ Pipeline smoke test: plan→tasks→review completed successfully"

      # =========================================================================
      # P5: Full 6-Stage Pipeline Smoke Test (SPEC-KIT-921)
      # =========================================================================

      - name: "[PIPELINE] full 6-stage progression test (specify deferred)"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          STAGES=("plan" "tasks" "implement" "validate" "audit" "unlock")

          for STAGE in "${STAGES[@]}"; do
            echo "Testing stage: $STAGE"
            OUTPUT=$(${{ env.CLI }} speckit "$STAGE" \
              --spec SPEC-CI-001-clean \
              --dry-run \
              --json)

            # Verify status is ready and stage matches
            echo "$OUTPUT" | jq -e '.status == "ready"' > /dev/null || { echo "::error::Stage $STAGE should have status='ready'"; exit 1; }
            echo "$OUTPUT" | jq -e '.schema_version == 1' > /dev/null || { echo "::error::Stage $STAGE should have schema_version=1"; exit 1; }

            # Verify stage matches (case-insensitive check via contains)
            STAGE_UPPER=$(echo "$STAGE" | sed 's/^./\U&/')  # Capitalize first letter
            echo "$OUTPUT" | jq -e --arg s "$STAGE_UPPER" '.stage | contains($s)' > /dev/null || { echo "::error::Stage output should contain '$STAGE_UPPER'"; exit 1; }

            echo "  ✓ $STAGE: exit 0, status=ready"
          done

          echo "✓ Full pipeline smoke test: plan→tasks→implement→validate→audit→unlock completed successfully"

      # =========================================================================
      # P7: Batch Validation with 'run' Command (SPEC-KIT-921)
      # =========================================================================

      - name: "[RUN] Batch validate plan→audit (efficient CI check)"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          OUTPUT=$(${{ env.CLI }} speckit run \
            --spec SPEC-CI-001-clean \
            --from plan \
            --to audit \
            --json)

          # Validate run command output structure
          echo "$OUTPUT" | jq -e '.schema_version == 1' > /dev/null || { echo "::error::schema_version should be 1"; exit 1; }
          echo "$OUTPUT" | jq -e '.overall_status == "ready"' > /dev/null || { echo "::error::overall_status should be 'ready'"; exit 1; }
          echo "$OUTPUT" | jq -e '.from_stage' > /dev/null || { echo "::error::Missing from_stage field"; exit 1; }
          echo "$OUTPUT" | jq -e '.to_stage' > /dev/null || { echo "::error::Missing to_stage field"; exit 1; }
          echo "$OUTPUT" | jq -e '.stages | length > 0' > /dev/null || { echo "::error::stages array should not be empty"; exit 1; }
          echo "$OUTPUT" | jq -e '.exit_code == 0' > /dev/null || { echo "::error::exit_code should be 0 for ready status"; exit 1; }

          # Verify per-stage results are present
          STAGE_COUNT=$(echo "$OUTPUT" | jq '.stages | length')
          echo "  Validated $STAGE_COUNT stages in batch"

          echo "✓ Run command: plan→audit batch validation passed"

      - name: "[STATUS] Validate status command JSON structure"
        working-directory: ${{ env.FIXTURE_ROOT }}
        run: |
          set -o pipefail
          OUTPUT=$(${{ env.CLI }} speckit status \
            --spec SPEC-CI-001-clean \
            --json)

          # Validate status command output structure
          echo "$OUTPUT" | jq -e '.schema_version == 1' > /dev/null || { echo "::error::schema_version should be 1"; exit 1; }
          echo "$OUTPUT" | jq -e '.spec_id' > /dev/null || { echo "::error::Missing spec_id field"; exit 1; }
          echo "$OUTPUT" | jq -e '.generated_at' > /dev/null || { echo "::error::Missing generated_at field"; exit 1; }
          echo "$OUTPUT" | jq -e '.stages' > /dev/null || { echo "::error::Missing stages field"; exit 1; }
          echo "$OUTPUT" | jq -e '.evidence' > /dev/null || { echo "::error::Missing evidence field"; exit 1; }

          echo "✓ Status command: JSON structure validated"

      # =========================================================================
      # Failure Diagnostics
      # =========================================================================

      - name: Capture diagnostic artifacts on failure
        if: failure()
        run: |
          mkdir -p /tmp/spec-kit-debug

          # Capture CLI version
          ${{ env.CLI }} --version > /tmp/spec-kit-debug/cli-version.txt 2>&1 || true

          # Capture environment (no secrets)
          env | grep -E '^(CARGO|RUST|GITHUB_|CI)' > /tmp/spec-kit-debug/env.txt

          # Run all cases with --explain for debugging gold
          echo "=== CLEAN CASE ===" > /tmp/spec-kit-debug/all-cases.log
          cd ${{ env.FIXTURE_ROOT }} && \
            ${{ env.CLI }} speckit review --spec SPEC-CI-001-clean --stage plan --json --explain \
            >> /tmp/spec-kit-debug/all-cases.log 2>&1 || true

          echo -e "\n=== CONFLICT CASE ===" >> /tmp/spec-kit-debug/all-cases.log
          cd ${{ env.FIXTURE_ROOT }} && \
            ${{ env.CLI }} speckit review --spec SPEC-CI-001-conflict --stage plan --json --explain \
            >> /tmp/spec-kit-debug/all-cases.log 2>&1 || true

          echo -e "\n=== MALFORMED CASE ===" >> /tmp/spec-kit-debug/all-cases.log
          cd ${{ env.FIXTURE_ROOT }} && \
            ${{ env.CLI }} speckit review --spec SPEC-CI-001-malformed --stage plan --json --explain \
            >> /tmp/spec-kit-debug/all-cases.log 2>&1 || true

          echo -e "\n=== STATUS (for context) ===" >> /tmp/spec-kit-debug/all-cases.log
          cd ${{ env.FIXTURE_ROOT }} && \
            ${{ env.CLI }} speckit status --spec SPEC-CI-001-clean --json \
            >> /tmp/spec-kit-debug/all-cases.log 2>&1 || true

      - name: Upload diagnostic artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: spec-kit-debug
          path: /tmp/spec-kit-debug/
          retention-days: 5

  spec-kit-unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache-workspaces: codex-rs

      - name: Run spec-kit unit tests
        working-directory: codex-rs
        run: cargo test -p codex-spec-kit

      - name: Run CLI integration tests
        working-directory: codex-rs
        run: cargo test -p codex-cli --test speckit
